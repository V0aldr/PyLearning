class D:
    __slots__ = ['a', 'b', '__dict__']  # Указание__ diet__ для его включения
    c = 3  # Атрибуты класса работают нормально

    def __init__(self):
        self.d = 4  # d хранится в __dict__ , а является слотом


d = D()
print(f"{d.d = }")
print(f"{d.c = }")
# print(f"{d.a = }")                            # AttributeError: 'D' object has no attribute 'a'
d.a = 1  # из-за присутствия __dict__ в __slots__ динамически доб-ся "a" & "b"
d.b = 5
print(f"{d.a = }")
print(f"{d.b = }")
print('-' * 20)
print(f"{d.__dict__ = }")
print(f"{d.__slots__ = }")
print(f"{'getattr: ':-^80}")
print(getattr(d, 'a'), getattr(d, 'c'), getattr(d, 'd'), sep='\n')
print(f"{'getattr in for: ':-^80}")
for a in (i for i in dir(d) if not i.startswith('__')):
    print(a, '=>', getattr(d, a))
print(f"{'Правила __slots__':-^80}")
print(f"{'Слоты в подклассах бессмысленны':-^80}")

'''
Слоты в подклассах бессмысленны, когда они отсутствуют в суперклассах.
Если подкласс унаследован от суперкласса без__ slots__ , то атрибут__ diet__
экземпляра, созданный для суперкласса, будет всегда доступен, делая атрибут
__ slots__ в подклассе по существу бессмысленным. Подкласс по-прежнему уп­
равляет своими слотами, но никак не вычисляет их значения и не избегает сло­
варя — главной причины применения слотов
'''


class A: pass


class B(A):
    __slots__ = ['a']


b = B()
b.a, b.b = 1, 2
print(f"{b.__dict__ = }")
print(f"{B.__dict__.keys() = }")

print(f"{'Слоты в суперклассах бессмысленны':-^80}")
'''
Слоты в суперклассах бессмысленны, когда они отсутствуют в подклассах.
Аналогично, поскольку объявление__ slots__ ограничено классом, в котором
оно появляется, подклассы будут создавать__ diet__ экземпляра, если в них не
определен атрибут__ slots__ , делая__ slots__ в суперклассе в сущности бес­
смысленным.
'''


class C: __slots__ = ['a']


class E(C): pass


e = E()
e.a, e.b = 1, 2
print(f"{e.__dict__ = }")
print(f"{C.__dict__.keys() = }")

print(f"{'Переопределение делает бессмысленными слоты суперкласса':-^80}")
'''
Переопределение делает бессмысленными слоты суперкласса. Если класс
определяет такое же слотовое имя, как в суперклассе, то согласно нормальному
наследованию его переопределение скрывает слот из суперкласса. Вы можете
получить доступ к версии имени, которая определена в слоте суперкласса, толь­
ко путем извлечения его дескриптора напрямую из суперкласса.
'''


class Q: __slots__ = ['а']  # Пункт 3: доступен только самый нижний слот
class W(Q): __slots__ = ['а']


print(f"{'Слоты препятствуют определению стандартных имен':-^80}")
'''
Слоты препятствуют определению стандартных имен. Поскольку слоты
реализованы в виде дескрипторов уровня класса (вместе с пространством для
каждого экземпляра), вы не можете использовать атрибуты класса с такими же
именами для предоставления стандартных имен, как могли бы делать для нор­
мальных атрибутов экземпляра: присваивание значения тому же самому имени в
классе переопределяет дескриптор слота.
'''

class R: __slots__ = ['а']; а = 99  # стандартные имена уровня класса отсутствуют
#ValueError: 'a' in __ slots__ conflicts with class variable
#Ошибка значения: а в__ slots__ конфликтует с переменной класса


print(f"{'Слоты и __dict__ ':-^80}")
'''
Слоты и__ diet__ . Как было показано ранее, список__ slots__ предотвращает
существование __diet__ экземпляра и присваивание значений именам, отсутс­
твующим в списке, если__ diet__ явно не включен в список.
'''
print(f"{' ':-^80}")
